# 模板和泛型编程

## 目录

- [模板和泛型编程](#模板和泛型编程)
  - [目录](#目录)
  - [1 模板](#1-模板)
    - [1.1 函数模板](#11-函数模板)
    - [1.2 类模板](#12-类模板)
    - [1.3 模板的全特化和偏特化](#13-模板的全特化和偏特化)
  - [2 顺序容器](#2-顺序容器)

## 1 模板

模板是C++特性之一，也是STL的基础，**利用模板可以编写类型无关的代码**，从而提高编程效率。

### 1.1 函数模板

- 编写函数的时候，如果参数类型不确定，需要编写一组重载函数，以满足不同数据类型的需求。而一旦函数逻辑发生变化，所有的重载函数都得随之改变，这无形中增加了维护的成本
- 可以通过函数模板解决这个问题

```cpp
template<typename T>
int compare(const T &v1, const T &v2){
    if(v1 < v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}
int r1 = compare(1, 10);
int r2 = compare(1.2, 1.8);
```

- 函数模板声明以关键字template开头，后面跟着模板参数列表，列表中的每一个参数都由typename关键字修饰，多个参数之间用逗号分隔开。
- 调用函数模板时，无需显示指定模板参数的类型。
- 可以显示指定类型，如上面的函数也可以使用`int r = compare<double>(1.2, 1.8);`
- **函数模板不适用于所有数据类型**，只有支持比较操作符`<`的类型才能使用这个模板，类似`char[]`就不能使用，除非用特化函数模板方式解决。
- 只有模板函数的类型完全一致的时候，函数模板才会实例化一个模板函数。

### 1.2 类模板

类模板数据成员和函数成员都可以使用模板中的待定类型。与函数模板不同，类模板在实例化的时候**必须指定模板参数的类型**。

```cpp
template<typename T>class Test{
    public:
        Test(T a):a(a) {};
        void set(const T &a) {this->a = a;}
        T get() {return a;}
    
    private:
        T a;
}

Test<int> t1(100);
Test<char> t2('a');
```

### 1.3 模板的全特化和偏特化

- 全特化是针对模板参数的特定类型进行完全的定制。当你需要为某个特定类型提供一个完全不同的实现时，可以使用全特化。

```cpp
template<typename T>
class MyClass {
public:
    void print() {
        std::cout << "General template" << std::endl;
    }
};

// 全特化
template<>
class MyClass<int> {
public:
    void print() {
        std::cout << "Specialized for int" << std::endl;
    }
};
```

- 偏特化是指只针对模板参数的一部分进行特化，而不是对所有模板参数进行完全特化。它允许你为某些特定的参数组合提供定制的实现。

```cpp
// 普通模板
template<typename T>
class MyClass {
public:
    void print() {
        std::cout << "General template" << std::endl;
    }
};

// 偏特化（针对指针类型）
template<typename T>
class MyClass<T*> {
public:
    void print() {
        std::cout << "Specialized for pointer types" << std::endl;
    }
};
```

**注：函数模板只能全特化，不能偏特化。**

## 2 顺序容器
