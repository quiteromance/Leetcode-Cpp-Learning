# 科大讯飞面经

## 目录

- [科大讯飞面经](#科大讯飞面经)
  - [目录](#目录)
  - [1. 计算机网络](#1-计算机网络)
    - [1.1 TCP的拥塞控制](#11-tcp的拥塞控制)
    - [1.2 TCP可靠性](#12-tcp可靠性)
    - [1.3 流量控制](#13-流量控制)
    - [1.4 TCP的四次挥手](#14-tcp的四次挥手)
    - [1.5 TIME\_WAIT()产生原因](#15-time_wait产生原因)
    - [1.6 为什么要等待2MSL而不是1或者3MSL](#16-为什么要等待2msl而不是1或者3msl)
    - [1.7 TIME\_WAIT和CLOSE\_WAIT产生过多原因](#17-time_wait和close_wait产生过多原因)
    - [1.8 Linux用什么工具/cmd怎么查看TCP状态](#18-linux用什么工具cmd怎么查看tcp状态)
    - [1.9 视频会议是用TCP还是UDP，为什么用UDP](#19-视频会议是用tcp还是udp为什么用udp)
    - [1.10 数据包从我的电脑到你的电脑经历过那些过程，用到那些协议](#110-数据包从我的电脑到你的电脑经历过那些过程用到那些协议)
  - [2. C++特性](#2-c特性)
    - [2.1 C和C++的区别](#21-c和c的区别)
    - [2.2 RAII](#22-raii)
    - [2.3  智能指针如何解决内存泄漏](#23--智能指针如何解决内存泄漏)
    - [2.4 C++多态的实现方式](#24-c多态的实现方式)
      - [运行时多态（动态多态）](#运行时多态动态多态)
      - [编译时多态（静态多态）](#编译时多态静态多态)
    - [2.5 动态多态的实现原理](#25-动态多态的实现原理)
    - [2.6 虚函数在使用时候的注意事项](#26-虚函数在使用时候的注意事项)
    - [2.7 什么是虚继承](#27-什么是虚继承)
    - [2.8 new和malloc的区别](#28-new和malloc的区别)
    - [2.9 static在修饰全局变量，成员变量，局部变量的区别](#29-static在修饰全局变量成员变量局部变量的区别)
    - [2.10 指针和引用的区别](#210-指针和引用的区别)
  - [3 LINUX提问](#3-linux提问)
    - [3.1 用户态和内核态](#31-用户态和内核态)
    - [3.2 用户态和内核态如何切换](#32-用户态和内核态如何切换)
    - [3.3 linux查找文件的方法有那些](#33-linux查找文件的方法有那些)
    - [3.4 find和locate的区别](#34-find和locate的区别)
  - [4. 进程线程](#4-进程线程)
    - [4.1 操作系统如何做到进程隔离的](#41-操作系统如何做到进程隔离的)
    - [4.2 进程间通信的方式](#42-进程间通信的方式)
    - [4.3 线程同步的方式](#43-线程同步的方式)
    - [4.4 进程调度策略](#44-进程调度策略)
    - [4.5 原子操作](#45-原子操作)
  - [5 socket网络编程](#5-socket网络编程)
    - [5.1 select和epoll的区别](#51-select和epoll的区别)
    - [5.2 epoll的两种实现模式是什么](#52-epoll的两种实现模式是什么)

## 1. 计算机网络

### 1.1 TCP的拥塞控制

TCP的拥塞控制，慢启动，快恢复，快重传（拥塞控制，什么时候慢开始，什么时候快恢复）？  

当网络对资源的需求大于当前网络可用的资源时，网络会发生拥塞。所谓**拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或者链路不至于过载**。拥塞控制是一个全局性的过程，设计网络种所有主机和路由器。  

拥塞控制算法：

- 慢开始：

  - 当主机开始发送数据的时候，由于不知道网络的拥塞情况，设置一个拥塞窗口，让发送窗口等于拥塞窗口，随后会从小到大的增加拥塞窗口的值。
  - 发送报文如果能接收到回复，说明网络不拥塞，这个时候就将拥塞窗口翻倍。比如一开始将拥塞窗口的值设置成1，确认以后就将拥塞窗口设置为2，设置为4，以此类推
  - 当拥塞窗口大于慢开始门限的时候，就执行拥塞避免算法。
- 拥塞避免：

  - 拥塞避免算法思路是让拥塞窗口cwnd缓慢的增大，即每次经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1。
  - 当拥塞窗口达到一定的时候的时候发生超时，此时调整门限为原来的1/2，同时设置cwnd=1，重新开始慢开始算法。
- 快重传

  - 快重传可以让发送方尽快直到个别报文段的丢失。
  - 快重传算法要求接收方立刻发送确认报文，即使是自己收到了失序的报文。比如M3报文没有接受，发送方发送M4，M5，M6报文并被接受接收方以后也会重复发送M2的确认报文。
  - 快重传算法规定，发送方只要连续接收到了三个重复确认，截止到没有接收到M3，需要立刻重新发送M3.

- 快恢复

  - 快重传以后直接将门限调整为原来的1/2，并且执行拥塞避免算法。

### 1.2 TCP可靠性

TCP要如何保证其可靠性？  

TCP是可靠连接，他保证通过TCP连接传输的数据无差错，不丢失，没有重复，按顺序到达。TCP主要是靠以下技术实现可靠传输：

- TCP通过三次握手和四次挥手确保双方准备好数据传输和终止连接。
- TCP将字节流划分成多个报文段，每个报文段都有序列号和确认号。接收方接收到报文会发送应答，如果一段时间没有回复就会触发超时重传机制。
- 以字节为单位的滑动窗口。
- TCP的流量控制。
- TCP的拥塞控制。

### 1.3 流量控制

TCP流量控制怎么做？  

如果发送方把数据发送的太快，接收方来不及接收就会造成数据的丢失。流量控制（flow control）就是让发送方发送速率不要太快。通过在建立连接后设置接收窗口的大小来实现。

- 建立连接时，B告诉A“我的接收窗口rwnd = 400”。发送方的发送窗口不能超过接收方的接收窗口。
- B可以通过接收窗口的大小来进行流量控制，当rwnd = 0时，A停止发送报文直到B发送一个新的窗口值。
- 如果B发送的rwnd报文丢失了，A会一直处于等待状态，B也会处于等待A发送报文的状态，这个时候就会发生死锁。此时TCP会启动计时器，当连接的一方接收到零窗口通知就会启动，每隔一段时间会发送一个探测报文，对方接受到以后就会给出现在的窗口值，接收到以后就重制计时器。

### 1.4 TCP的四次挥手

数据传输结束后，通信的双方都可以释放连接。现在A和B都处于ESTABLISHED状态。

- A应用先向TCP发出连接释放报文，并停止再发送数据。A把连接释放报文段的首部终止控制位FIN置1，其序号seq=u，等于前面传送数据最后一个字节的序号+1.这时A进入FIN-WAIT-1（停止等待1）状态，等待B的确认。FIN报文不携带数据也会消耗一个序号。
- B收到连接释放报文段后发出确认。确认号ack=u+1，这个报文自己的seq=v。然后B进入CLOSE-WAIT（关闭等待）的状态。TCP服务器通知高层应用，从A到B这个方向的连接就释放了。这时TCP连接处于半关闭状态。因为A没有数据要发送了，但是如果B发送数据，A仍要接收。
- A收到B的确认报文后，会进入FIN-WAIT-2（停止等待2）状态，等待B释放报文段。
- 如果B没有要向A发送的报文，B发出的连接释放报文使FIN=1，假定B的序号是w。B要重复上一个发送过的ack=u+1。这时**B进入LAST-ACK（最后确认）**状态。
- A收到B的连接释放报文后，必须发出确认，确认报文ACK置1，确认号ack=w+1，自己的序号是seq=u+1.随后进入到TIME-WAIT状态。经过时间等待计时器设置时间2MSL后，A进入CLOSE状态。

TCP四次挥手会什么会有四次挥手？

### 1.5 TIME_WAIT()产生原因

- 为了保证A发送的最后一个ACK报文段能到达B。假设ACK报文丢失，接收到B的超时重传报文，A就会在2MSL时间内首段重传报文，然后重置2MSL时间。如果没有这个2MSL时间，B重传以后如果没有接收到确认报文，就无法进入释放连接。
- 假设A发送完最后一个ACK报文以后，经过2MSL时间后就会让所有的报文段从网络中消失。这样就不会让新的连接出现旧的报文。

### 1.6 为什么要等待2MSL而不是1或者3MSL

MSL是报文的最大生存时间，最坏情况是去向ACK消息最大存活时间（MSL）+ 来向FIN消息的最大存活时间(MSL)。这恰恰就是2MSL( Maximum Segment Life)。

### 1.7 TIME_WAIT和CLOSE_WAIT产生过多原因

- TIME_WAIT:

  - TCP连接在关闭后，会进入一个TIME_WAIT的状态，持续的时间一般在1-4分钟，对于连接数不高的场景，1-4分钟其实并不长，对系统也不会有什么影响.但是如果短时间内进行大量的短连接，客户端所在的操作系统的socket端口和文件描述符被用尽，系统无法再发起新的连接！
  - 解决方法：

    - 修改为长连接
    - 修改ipv4.ip_local_port_range，增大可用端口的范围

- CLOSE_WAIT:

  - FIN包的底层实现其实就是调用socket的close方法，这里的问题出在没有执行close方法。说明服务端socket忙于读写。
  - 解决方法：

    - 使用完socket调用close方法；

### 1.8 Linux用什么工具/cmd怎么查看TCP状态

- netstat
- 读取 /proc/net/tcp 文件
- tcpdump ，可以用来监控实时的TCP连接流量。

### 1.9 视频会议是用TCP还是UDP，为什么用UDP

- UDP是尽最大努力交付，不需要超时重传，对于视频会议这种实时的视频会议，如果使用TCP会破坏视频的实时性。
- UDP支持一对多的通信，视频会议一般都是很多人在一起开，这个时候UDP比较适合。
- UDP没有拥塞控制，网络出现拥塞不会使源主机发送速率降低。

### 1.10 数据包从我的电脑到你的电脑经历过那些过程，用到那些协议

- 应用层：应用程序（例如浏览器、聊天应用等）生成数据包。比如http或https协议将数据发送到网络的服务器上，或者使用SMTP/POP3用于邮件传输。
- 传输层：TCP/UDP协议。
- 网络层：IP协议
- 数据链路层：WIFI/PPP/以太网协议。  

  - 首先电脑生成数据，在传输层被分段，TCP对报文封装后传入网络层。
  - 网络层经过IP协议对报文继续封装，然后通过路由发送到网络中。
  - 路由选择最佳路径，根据路由表决定吓一跳。
  - 到达目的网络，最后一跳会通过ARP协议将目的地址解析为MAC地址，通过WIFI或者以太网传输。
  - 目标计算机接收

## 2. C++特性

### 2.1 C和C++的区别

- C语言是一门面向过程的语言，侧重于通过过程来解决问题。C++是一门多范式语言，主要支持面向对象，侧重于使用类和对象来组织代码。
- C++支持继承，允许子类继承父类达到代码复用的目的，C没有继承的概念
- C++支持函数重载，函数名必须唯一。
- C++支持模板，支持静态动态形式的多态；C语言不支持。
- C++使用new和delete管理内存，也支持用智能指针动态管理内存，C语言需要用malloc和free来申请和释放内存。
- C++的stl标准库比C丰富的多。如vector，string等。

### 2.2 RAII

RAII（resource acquisition is initialization）资源获取即初始化。C++种RAII即资源在构造函数中完成初始化，出了作用域就会自动被清理释放。常用在资源泄露和死锁。

### 2.3  智能指针如何解决内存泄漏

智能指针是一个类模板，对普通指针进行了一层封装，模板参数是指针指向的类型，通过重载->和*两个操作符使智能指针和普通指针用法相同。在智能指针对象生命周期结束时自动调用析构函数，释放其管理的动态内存。通过析构函数释放指针指向的空间。

- 自动管理内存释放：当智能指针超出作用域时，智能指针的析构函数会自动调用 delete，释放内存。
- 避免重复释放：智能指针确保内存只会被释放一次，避免了常见的双重释放问题。
- 避免悬空指针：智能指针会自动将管理的指针置空，避免访问已经释放的内存。

### 2.4 C++多态的实现方式

#### 运行时多态（动态多态）

通过继承和虚函数来实现。虚函数（virtual function）允许派生类重写基类中的函数，从而使得基类的指针或引用能够调用派生类的实现。多态性的原理是延迟绑定，就是在函数调用的时候才绑定函数，这也是虚函数的工作原理。

- 通过继承和虚函数来实现。
- 父类的指针或引用可以指向子类对象，调用虚函数时，根据对象的实际类型（子类类型）决定调用哪个实现。
- 运行时多态是通过动态绑定实现的，函数调用会在运行时根据对象的实际类型进行决定。

#### 编译时多态（静态多态）

- 静态多态主要借助模板和重载。在编译期间，编译器通过类型来实例化模板或者选择合适的重载。因此，静态多态在编译期间完成。

- 模板的类型识别和实例化过程在编译期完成。具体类型是在编译期根据使用模板时传入的参数类型来确定的，编译器会基于模板参数生成具体的代码。

### 2.5 动态多态的实现原理

- 当基类拥有虚函数成员，那么基类本身的大小就不再是成员变量占用的内存，而是多出了一个指针，该指针指向了一个函数指针数组，数组中存放了基类虚函数的地址。指针在类对象模型的顶部。
- 派生类会在继承基类成员变量的同时拷贝一份基类的虚表。如果派生类重写了基类的虚函数，那么派生类就会在它的虚表中将该虚函数原来的地址改成重写后的虚函数的地址。同时，派生类自己的虚函数也会按照声明次序依次被添加到虚表的最后。

### 2.6 虚函数在使用时候的注意事项

- 构造函数不能声明称虚函数，因为它们在这些阶段只会调用基类的版本。
- 基类的析构函数应该是虚函数。
- 内联函数不能是虚函数。
- 静态函数不能是虚函数。
- 虚函数有继承属性。

### 2.7 什么是虚继承

多重继承指一个子类继承多个父类，在多重继承体系中，有一种比较特殊的继承关系叫菱形继承，指多重继承中的多个父类又继承自同一个子类。如B，C继承自A，D又继承自B，C。菱形继承中存在访问二义性问题：D间接继承了A两次，如果A类中有int a的公有成员，D就有两个数据成员a。当访问D中的a时，无法判断a是通过B继承A还是通过C继承A。为了使得D只继承顶层的类A一次，从而使类D中只有唯一的一份数据成员a，必须在类A的直接子类中使用虚继承。

- 虚继承通过virtual关键字修饰继承关系，类A子类的对象中增加了一个指向A的指针。
- 虚继承避免了访问二义性的问题。

### 2.8 new和malloc的区别

- new/delete是C++提供的运算符，而malloc/free在C和C++中都可以使用
- new后面给定了指明的指针类型，而malloc需要显示的转换指针类型
- new和delete可以用于面向对象的自定义类型，malloc只能用于基本类型。
- new会调用构造函数初始化，malloc只负责申请空间。

### 2.9 static在修饰全局变量，成员变量，局部变量的区别

- static修饰全局变量，代表这个全局变量作用域只在这个文件内，在其它文件不可见，不能被extern到其他代码段中。生命周期为整个文件。
- static修饰成员变量，它不属于类的任何具体对象，而是属于类本身。所有的对象共享同一个静态成员变量。在类内声明，在类外初始化。静态成员变量在程序开始时被初始化，并在程序结束时被销毁。它的生命周期与程序的生命周期相同。
- static修饰局部变量，该变量的作用域仍然是在其定义的函数内，但是它的生命周期会延长到程序的整个运行期间，而不是局部作用域结束时被销毁。静态局部变量只在第一次调用函数时进行初始化，之后其值保持不变，直到程序结束。每次函数调用时，静态局部变量不会重新初始化。

### 2.10 指针和引用的区别

- 定义      变量的地址                        已存在变量的别名
- 初始化    可以不初始化，之后可以指向其他地址  必须初始化，不能更改引用对象的指向
- 空值      可以是 nullptr                   不能是空的
- 访问语法  使用 * 解引用                     直接使用引用
- 参数传递  可以传递空指针                    不能传递空引用
- 使用灵活性 更加灵活                         更加安全
- 适用场景 动态内存管理、数据结构              参数传递、返回值

## 3 LINUX提问

### 3.1 用户态和内核态

- 用户态：只能执行一部分机器指令，不可以运行IO命令或者影响及其控制的指令。
- 内核态：可以访问所有的硬件设备，也可以执行硬件上能运行的各种指令。

### 3.2 用户态和内核态如何切换

- 通过 syscall 发动了用户态向内核态的系统调用：

  - 将参数保存到寄存器中
  - 根据系统调用名得到系统调用号，保存到寄存器rax中
  - syscall将用户态陷入内核态
  - 内核态通过相应的寄存器参数调用相应的内核态方法
- 中断
- 异常

### 3.3 linux查找文件的方法有那些

find，locate，which/where is（查找命令的路径）

### 3.4 find和locate的区别

- find直接在指定目录中递归遍历搜索文件，实时搜索，能够立即反映文件系统的最新状态（例如新建或删除文件）。不依赖数据库，逐个文件扫描，搜索结果精确。
- locate基于一个定期更新的文件名数据库（由 updatedb 命令创建和更新），因此搜索速度非常快。不进行实时搜索，依赖于数据库的最新状态。如果文件系统中的文件被修改、添加或删除，但 updatedb 尚未更新，locate 的结果可能不准确。

## 4. 进程线程

### 4.1 操作系统如何做到进程隔离的

操作系统采用**虚拟内存管理技术**实现进程隔离，这是因为每个进程的页表条目指向RAM（或交换区）中截然不同的物理页面集合。进程A和进程B的虚拟地址空间不同，从而防止A和B的数据交互。

### 4.2 进程间通信的方式

主要通过五种方式通信：

- 管道通信

  - 管道是用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。向管道提供输入的写进程，以字符流的形式将数据送入管道，接受管道输出的读进程，从管道接收数据，从而实现进程间的通信。
- 消息队列

  - 消息队列是保存在内核中的消息链表，按照消息类型进行传递。
- 共享内存

  - 共享内存是一段可以被所有进程访问的内存，通过对这片共享空间进行读/写操作可以实现进程间的信息交换。
- 信号量

  - 一个信号量是一个由内核维护的整数，是一个计数器。它常作为一种锁机制，与共享内存结合起来使用，比如一个进程减小一个信号量（如从1 到0）是为了预约对某些共享资源的独占访问。
- 信号和套接字

  - 信号是一种异步通信机制，用于通知接收进程某个事件已经发生，比如使用kill命令，就是给进程发信号。套接字不仅可以用于不同主机间的进程间通信，也可以用于本地主机上的进程间通信。

### 4.3 线程同步的方式

线程同步：进程间的多个线程占用同一个地址空间，为了避免多个线程同时访问数据造成混乱，需要考虑线程的同步问题。**线程同步就是按照预定的先后顺序访问共享资源，以免造成混乱**。线程同步的方式主要有：

- 互斥锁

  - 互斥锁在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量进行解锁，对互斥量加锁以后，任何想要访问对互斥量加锁的线程都会被阻塞。
- 自旋锁

  - 自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。
- 读写锁

  - 读写锁可以对读模式和写模式分别加锁。一次只能有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。
- 条件变量

  - 当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁。
  - 条件变量允许线程阻塞并等待另一个线程发送信号，一般和互斥锁一起使用。条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。
- 屏障

  - 屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。
- 信号量

  - 信号量本质是一个计数器，用于为**多个进程提供共享数据对象的访问**，可以根据信号量值来判断线程是否对公共资源有访问的权限。

### 4.4 进程调度策略

- 先进先出（FIFO）

  - 先到的任务先处理

- 最短任务优先（SJF：Shortest Job First）

  - 优先处理最短任务

- 抢占式最短任务优先（PSJF：Preemptive Shortest Job First）
  
  - 优先处理用时最短的任务，可在必要时抢占
- 轮询调度（RR：Round Robin）
  
### 4.5 原子操作

## 5 socket网络编程

### 5.1 select和epoll的区别

- 对于待检测集合select是基于线性表来处理的；epoll是基于红黑树来管理检测集合的。
- select每一次都会线性扫描待检测集合，集合越大速度越慢；epoll是回调机制，效率高，处理速度不会随检测集合变大而下降。
- select存在用户空间到内核数据频繁拷贝的问题，epoll中内核和用户区使用的共享内存，省去了不必要的内存拷贝
- 需要对select返回的集合判断那些文件描述符是就绪的，通过epoll可以直接得到就绪的文件描述符集合
- epoll没有最大文件描述符的限制。

### 5.2 epoll的两种实现模式是什么

- 水平触发（LT）默认模式

  - 在LT模式中，内核通知使用者那些文件描述符已经就绪，之后就可以对已经就绪的文件描述符进行IO操作。如果不操作的话，内核还是会继续通知。
- 边沿触发（ET）
  
  - 在LT模式中，内核通知使用者那些文件描述符已经就绪，之后就可以对已经就绪的文件描述符进行IO操作。但是只会对使用者一次通知。