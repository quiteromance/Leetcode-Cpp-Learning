# 内存管理

## 目录

- [内存管理](#内存管理)
  - [目录](#目录)
  - [1. 堆内存和栈内存](#1-堆内存和栈内存)
    - [1.1 判断存储区](#11-判断存储区)
    - [1.2 栈空间和堆空间的区别](#12-栈空间和堆空间的区别)
    - [1.3 递归算法的问题](#13-递归算法的问题)
  - [2. 内存泄露](#2-内存泄露)
    - [2.1 预防内存泄露的方法](#21-预防内存泄露的方法)
    - [2.2 不易察觉的内存泄漏](#22-不易察觉的内存泄漏)
  - [3. 内存越界](#3-内存越界)
    - [3.1 下标越界](#31-下标越界)

## 1. 堆内存和栈内存

在程序中，数据存放在不同的区段，通常分成四部分：

- **栈存储区**：存储**函数参数**和**局部变量**，这部分数据由编译器负责分配和回收，采用先进后出的方式。
- **堆存储区**：存储**动态分配的内存块**，这部分数据编译器不会自动处理，需要由程序员负责分配和回收。如果程序员没有主动释放内存空间，程序运行结束时，系统会回收这部分内存。
- **全局及静态存储区**：程序结束系统才会回收这一部分空间。
- **常量存储区**：用于存储常量数据的内存区域。这些常量可以指数字，字符串或其他类型的数据。

### 1.1 判断存储区

```cpp
int a = 0; //初始化全局变量a，保存在全局及静态存储区

int main(){
    char ch = 'a';
    static int c = 0; //静态变量c，保存在全局及静态存储区
    // p1-p4，ch都是局部变量，保存在栈里面。
    char *p1 = "abc"; 
    char *p2 = "abc";
    char *p3 = &ch;
    char *p4 = (char *)malloc(10);
    //“abc”保存在常量存储区，p1和p2指向同一块地址，p3指向栈，p4指向堆
}

```

### 1.2 栈空间和堆空间的区别

- 内存管理不同：栈空间用于存储函数参数和局部变量，所需空间由系统自动非陪，回收也由系统管理；堆空间存储动态分配的内存，分配和释放空间都由程序员控制，且有可能产生内存泄露。
- 内存连续性：栈分配的内存是连续的，堆分配的内存是碎片化的。
- 内存大小：栈的默认大小一般只有几M的空间，向着内存减小的方向消耗空间；堆理论有几个G的空间，向着内存地址增大的方向消耗空间。
- 栈的效率较高，分配和释放的速度比较快；堆的效率较低，分配释放的速度比较慢。

### 1.3 递归算法的问题

e.g.，二叉树的前序遍历：

```cpp
void preOrder(Tree *root){
    if(root != nullptr){
        visit(root);
        preOrder(root->left);
        preOrder(root->right);
    }

}
```

- **当递归层数过多的时候，可能会发生栈溢出**，每一层递归都会将当前的上下文压入函数栈，随着递归层数越来越多，压入栈的层数也越来越多，直到将栈空间用尽，而递归程序还没有返回，就会发生栈溢出。
- 可以用循环来代替递归实现，以避免栈溢出的问题。

```cpp
void preOrder(Tree *root){
    stack<Tree*> s;
    Tree *p = root;

    while(p != nullptr || !s.empty()){
        while(p != nullptr){
            visit(root);
            s.push(p);
            p = p->left;
        }

        if(!s.empty()){
            p = s.top();
            s.pop();
            p = p->right;
        }
    }
}
```

## 2. 内存泄露

- 内存泄漏：内存泄露指计算机程序没有合理的管理已经分配的内存，导致不再使用的内存没有及时的释放。随着程序运行时间的增长，泄露的内存越来越多，可用的内存越来越少，**最终无法为程序分配新的内存，进而导致程序崩溃**。
- 原因：**分配的内存没有及时回收**。由于在程序中malloc或者new从堆中申请了一块空间，但是在使用后并没有调用free或者delete释放。

### 2.1 预防内存泄露的方法

- 用智能指针（如std::unique_ptr和std::shared_ptr）代替普通指针管理内存。智能指针自带引用计数功能，能够记录动态分配空间的引用数量，在引用计数为0时，自动调用析构函数释放空间。e.g.

```cpp
#include <memory>

void useSmartPointer() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    // 内存会在函数结束时自动释放
}
```

- 保证*malloc*和*free*，*new*和*delete*成对出现。
- 借助内存泄露检测工具，例如valgrind等检测调试内存泄露。

### 2.2 不易察觉的内存泄漏

```cpp
void doSomething(int size){
    char *p = new char[size];
    if(!validationCheck(p, size)){
        cout << "error" << endl;
        return;
    }
    memoryOperation(p, size);
    delete p;

}
```

问题出在if后面的合法性检测，如果不合法直接return了，此时分配的char元素内存没有释放。修改以后的代码为：

```cpp
void doSomething(int size){
    char *p = new char[size];
    if(!validationCheck(p, size)){
        cout << "error" << endl;
        delete p;
        return;
    }
    memoryOperation(p, size);
    delete p;

}
```

## 3. 内存越界

- 内存越界（内存访问越界），指访问了所申请空间之外的内存，此时读取的结果具有随机性且无法预知。

```cpp
char a[8] = "hello";
memset(a, 0, 16);//初始化a首地址之后的16个字节。
```

### 3.1 下标越界

```cpp
int main(){
    vector<int> ivec(10);
    cout << ivec[0] << endl;
    cout << ivec[100] << endl;
    getchar();

}
```

vector容器重载了[]运算符，使得其能够像访问数组一样访问vector中的元素。[]用过将下标与first迭代器相加得到元素的地址，如果结果超过了finish迭代器的位置，程序不会报错，但是发生了数组越界。
