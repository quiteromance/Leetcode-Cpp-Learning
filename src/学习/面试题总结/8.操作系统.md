# 操作系统

## 目录

- [操作系统](#操作系统)
  - [目录](#目录)
  - [进程和线程](#进程和线程)
    - [进程和线程的区别](#进程和线程的区别)
    - [进程的平均周转时间](#进程的平均周转时间)
    - [进程隔离](#进程隔离)
    - [进程间通信方式](#进程间通信方式)
    - [线程同步的方式](#线程同步的方式)
    - [死锁](#死锁)
      - [产生死锁的原因](#产生死锁的原因)
      - [死锁产生的常见原因](#死锁产生的常见原因)
    - [如何定位死锁](#如何定位死锁)

## 进程和线程

- 进程是**具有独立功能的程序在某一个数据集合上的一次执行过程**。进程是系统进行资源分配和调度的一个独立单位。
- 线程是进程内的一个执行实体或执行单元，是比进程更小的能独立运行的基本单位。

### 进程和线程的区别

- 定义：进程是资源分配和调度的一个单位，线程是处理机调度和分配的单位，资源分配给进程，线程只有很少的资源，线程切换的代价比进程低。
- 内存分配：不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的。
- 开销：创建进程和撤销进程，系统都需要分配或者回收资源，操作系统开销远大于创建或撤销线程开销。

### 进程的平均周转时间

- 要获得最短的平均周转时间，可以使用短作业优先（SJF）调度算法。根据执行时间，将作业从短到长的顺序安排。

### 进程隔离

进程隔离是**指一个进程无法读取或修改内核或其他进程的内存内容**。进程隔离是操作系统内核对于资源管理和安全增强的特性，其最终的目的是对于操作系统内核能够更好的控制程序对资源的申请和使用，并且**控制此程序可访问资源的范围并限定此程序异常之后能够影响的范围**。

- 操作系统如何实现进程隔离：
  
  - 操作系统采用**虚拟内存管理技术**实现进程隔离，这是因为每个进程的页表条目指向RAM（或交换区）中截然不同的物理页面集合。进程A和进程B的虚拟地址空间不同，从而防止A和B的数据交互。

### 进程间通信方式

主要通过五种方式通信：

- 管道通信

  - 管道是用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件。向管道提供输入的写进程，以字符流的形式将数据送入管道，接受管道输出的读进程，从管道接收数据，从而实现进程间的通信。
- 消息队列

  - 消息队列是保存在内核中的消息链表，按照消息类型进行传递。
- 共享内存

  - 共享内存是一段可以被所有进程访问的内存，通过对这片共享空间进行读/写操作可以实现进程间的信息交换。
- 信号量

  - 一个信号量是一个由内核维护的整数，是一个计数器。它常作为一种锁机制，与共享内存结合起来使用，比如一个进程减小一个信号量（如从1 到0）是为了预约对某些共享资源的独占访问。
- 信号和套接字

  - 信号是一种异步通信机制，用于通知接收进程某个事件已经发生，比如使用kill命令，就是给进程发信号。套接字不仅可以用于不同主机间的进程间通信，也可以用于本地主机上的进程间通信。

### 线程同步的方式

线程同步：进程间的多个线程占用同一个地址空间，为了避免多个线程同时访问数据造成混乱，需要考虑线程的同步问题。**线程同步就是按照预定的先后顺序访问共享资源，以免造成混乱**。线程同步的方式主要有：

- 互斥锁

  - 互斥锁在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量进行解锁，对互斥量加锁以后，任何想要访问对互斥量加锁的线程都会被阻塞。
- 自旋锁

  - 自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。
- 读写锁

  - 读写锁可以对读模式和写模式分别加锁。一次只能有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。
- 条件变量

  - 当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁。
  - 条件变量允许线程阻塞并等待另一个线程发送信号，一般和互斥锁一起使用。条件变量被用来阻塞一个线程，当条件不满足时，线程会解开互斥锁，并等待条件发生变化。一旦其他线程改变了条件变量，将通知相应的阻塞线程，这些线程重新锁定互斥锁，然后执行后续代码，最后再解开互斥锁。
- 屏障

  - 屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。
- 信号量

  - 信号量本质是一个计数器，用于为**多个进程提供共享数据对象的访问**，可以根据信号量值来判断线程是否对公共资源有访问的权限。

### 死锁

死锁是指多个并发进程，各自持有资源又等待别的进程释放所有的资源，在未改变这种状态以前都不能向前推进，这种状态叫死锁。  

#### 产生死锁的原因

- 根本原因：系统的资源不足。
- 必要条件：

  - 互斥条件：并发进程要求和占用的资源只能被一个进程使用（即系统的资源在某一段时间只能被一个进程使用）。
  - 占有并等待：进程申请并等待新的资源过程中，继续占有已经分配的资源。
  - 不可剥夺：进程已经获得的资源，在没有使用完成前，都不可被剥夺，只能由进程自己释放。
  - 循环等待：若干进程形成首尾相接的循环链，循环等待上一个进程的资源。

#### 死锁产生的常见原因

- 资源竞争：当多个进程或线程同时竞争有限的资源（如 CPU、内存、I/O 设备、文件锁等）时，如果它们的**资源请求顺序不当或资源管理不合理**，容易导致死锁。
- 进程同步问题：进程或线程之间的**同步**问题，尤其是使用信号量、互斥锁（Mutex）、读写锁等进行同步时，可能会出现死锁。例如，两个线程分别占有对方需要的锁，并且互相等待对方释放锁，就会产生死锁。
- 不正确的资源分配策略：当系统资源分配策略不合理（如同时分配多个资源给进程，而不考虑资源的使用顺序或资源的占用时间），进程可能会进入等待资源的状态，导致死锁。
- 嵌套锁（Lock Nesting）：如果一个进程或线程在持有一个资源的同时试图获取另一个资源，而另一个进程或线程同时持有这两个资源的其中一个，可能会导致资源的相互等待，从而引发死锁。
- 未及时释放资源：进程在占用资源后未能及时释放资源，导致其他进程一直处于等待状态。例如，进程在使用资源后由于异常退出或逻辑错误未释放资源，会导致死锁。
- 资源的过度分配：如果系统同时为多个进程分配了过多的资源（尤其是在资源有限的情况下），可能会导致资源枯竭，进而引发死锁。

### 如何定位死锁

