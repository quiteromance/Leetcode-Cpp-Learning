# 内存管理

## 目录

- [内存管理](#内存管理)
  - [目录](#目录)
  - [1. 堆内存和栈内存](#1-堆内存和栈内存)
    - [1.1 判断存储区](#11-判断存储区)
    - [1.2 栈空间和堆空间的区别](#12-栈空间和堆空间的区别)
    - [1.3 递归算法的问题](#13-递归算法的问题)
  - [2. 内存泄露](#2-内存泄露)

## 1. 堆内存和栈内存

在程序中，数据存放在不同的区段，通常分成四部分：

- **栈存储区**：存储**函数参数**和**局部变量**，这部分数据由编译器负责分配和回收，采用先进后出的方式。
- **堆存储区**：存储**动态分配的内存块**，这部分数据编译器不会自动处理，需要由程序员负责分配和回收。如果程序员没有主动释放内存空间，程序运行结束时，系统会回收这部分内存。
- **全局及静态存储区**：程序结束系统才会回收这一部分空间。
- **常量存储区**：用于存储常量数据的内存区域。这些常量可以指数字，字符串或其他类型的数据。

### 1.1 判断存储区

```cpp
int a = 0; //初始化全局变量a，保存在全局及静态存储区

int main(){
    char ch = 'a';
    static int c = 0; //静态变量c，保存在全局及静态存储区
    // p1-p4，ch都是局部变量，保存在栈里面。
    char *p1 = "abc"; 
    char *p2 = "abc";
    char *p3 = &ch;
    char *p4 = (char *)malloc(10);
    //“abc”保存在常量存储区，p1和p2指向同一块地址，p3指向栈，p4指向堆
}

```

### 1.2 栈空间和堆空间的区别

- 内存管理不同：栈空间用于存储函数参数和局部变量，所需空间由系统自动非陪，回收也由系统管理；堆空间存储动态分配的内存，分配和释放空间都由程序员控制，且有可能产生内存泄露。
- 内存连续性：栈分配的内存是连续的，堆分配的内存是碎片化的。
- 内存大小：栈的默认大小一般只有几M的空间，向着内存减小的方向消耗空间；堆理论有几个G的空间，向着内存地址增大的方向消耗空间。
- 栈的效率较高，分配和释放的速度比较快；堆的效率较低，分配释放的速度比较慢。

### 1.3 递归算法的问题

e.g.，二叉树的前序遍历：

```cpp
void preOrder(Tree *root){
    if(root != nullptr){
        visit(root);
        preOrder(root->left);
        preOrder(root->right);
    }

}
```

- **当递归层数过多的时候，可能会发生栈溢出**，每一层递归都会将当前的上下文压入函数栈，随着递归层数越来越多，压入栈的层数也越来越多，直到将栈空间用尽，而递归程序还没有返回，就会发生栈溢出。
- 可以用循环来代替递归实现，以避免栈溢出的问题。

```cpp
void preOrder(Tree *root){
    stack<Tree*> s;
    Tree *p = root;

    while(p != nullptr || !s.empty()){
        while(p != nullptr){
            visit(root);
            s.push(p);
            p = p->left;
        }

        if(!s.empty()){
            p = s.top();
            s.pop();
            p = p->right;
        }
    }
}
```

## 2. 内存泄露



