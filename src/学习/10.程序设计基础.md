# 程序设计基础

## 目录

- [程序设计基础](#程序设计基础)
  - [目录](#目录)
  - [1. 程序的编译和执行](#1-程序的编译和执行)
    - [1.1 #include\<\>和#include ""的区别](#11-include和include-的区别)
    - [1.2 简述#和##在define中的作用](#12-简述和在define中的作用)
  - [2. 变量](#2-变量)
    - [2.1 C++的类型转换操作符](#21-c的类型转换操作符)
    - [2.2 静态全局变量](#22-静态全局变量)
  - [3. 宏定义和内联](#3-宏定义和内联)
    - [3.1 内联函数和宏定义的区别](#31-内联函数和宏定义的区别)
    - [3.2 宏展开错误](#32-宏展开错误)
    - [3.3 内联函数的常识性问题](#33-内联函数的常识性问题)
  - [4. 内存分配](#4-内存分配)
    - [4.1 malloc/free和new/delete的区别](#41-mallocfree和newdelete的区别)
    - [4.2 delete和delete\[\]的区别](#42-delete和delete的区别)
  - [5. main函数](#5-main函数)

## 1. 程序的编译和执行

### 1.1 #include<>和#include ""的区别

- #include<>直接从编译器指定的路径处搜索
- #include ""优先在当前目录下搜索，再从编译器指定的目录下搜索。

### 1.2 简述#和##在define中的作用

- #将后面的参数转换成字符串。e.g.

```cpp
#define PRINTCUBE(x) cout << "cube("<< #x <<") = " << (x) * (x) * (x) << endl;

int y = 5;
PRINTCUBE(5);
PRINTCUBE(y);

// 输出结果为：cube(5) = 125;cube(y) = 125;
```

- ##将前后参数进行字符串连接。e.g.

```cpp
#define LINK(x, y, z) x##y##z
LINK(3,5,0);

// 结果为350
```

## 2. 变量

### 2.1 C++的类型转换操作符

- C++提供了四种类型转换操作符：#static_cast#；#dynamic_cast#；#const_cast#和#reinterpret_cast#。
- static_cast可以代替C风格类型转化实现基本类型转换，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针（如果两个类是不相关的，则不可以相互转换）。
  - 需要注意的是，如果父类指针本就指向一个父类对象，此时将父类指针转换成子类指针虽然可以用static_cast实现，但是是不安全的；如果父类指针指向子类对象，则转换不存在安全性问题。

```cpp
class Base {};
class Derived : public Base {};

Base *b1 = new Base;
Base *b2 = new Derived;

Derived *b2d1 = static_cast<Derived*> (b1); //（不安全的转换）
Derived *b2d2 = static_cast<Derived*> (b2); // （安全的转换）
```

- dynamic_cast可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针。其在将父类指针转换成子类指针的过程中，需要对其背后的对象进行检查以确保类型完全批配（static_cast不会这样做）。当一个父类指针指向一个子类对象，且父类包含虚函数的时候，使用dynamic_cast转换子类指针才会成功，否则返回nullptr或抛出 std::bad_cast 异常（对于引用类型）。
  
```cpp
class Base {
public:
    virtual ~Base() {} // 必须有虚函数以使dynamic_cast起作用
};

class Derived1 : public Base {};

class Derived2 : public Base {};

Base *b1 = new Base;
Base *b2 = new Derived;

Derived *b2d1 = dynamic_cast<Derived*> (b1); //转换失败，返回nullptr
Derived *b2d2 = dynamic_cast<Derived*> (b2); //转换成功

Derived &b2d3 = dynamic_cast<Derived*> (b1); //转换失败，抛出 std::bad_cast 异常
Derived &b2d4 = dynamic_cast<Derived*> (b2); //转换成功

```

- const_cast可以在转换过程中增加或删除const属性。
- reinterpret_cast可以将一种类型的指针直接转换成另一种类型的指针（不论是否有继承关系），或者将指针类型转换为整数类型（反之亦然）。但需要开发者非常小心，因为这种转换可能会导致未定义行为（reinterpret_cast 不会进行任何运行时检查，因此转换的结果可能会导致未定义行为。必须确保转换是合理的）。

### 2.2 静态全局变量

静态全局变量的声明和定义放在源文件中，并且不能使用extern关键字将静态全局变量导出，因此静态全局变量的作用域仅限于定义静态全局变量的文件内部。而普通全局变量作用域是整个工程，在头文件中使用extern关键字声明普通全局变量。

**如果在头文件中声明静态全局变量，静态全局变量在声明的同时会被初始化**，如果静态全局变量没有显示地初始化则会默认初始化，相当于直接在头文件中进行声明和初始化；而**普通全局变量不能定义在头文件中。**（防止链接过程中的重复定义）

## 3. 宏定义和内联

宏定义是预处理器指令，用于在编译前进行文本替换。它们在C和C++编程中使用#define关键字来创建。在编译之前，**预处理器会扫描代码并将所有宏替换为其定义的文本**。宏定义也可以带参数(参数化宏)，类似于函数。这种宏在被调用时会进行参数替换。e.g.

```cpp
#define SQUARE(x) ((x) * (x))
```

参数化宏可能会引入意外的副作用，如果不小心处理，可能会导致难以发现的错误。例如，使用参数化宏时，应该总是使用括号包围参数和整个表达式，以避免运算优先级问题。故C++提出了内联函数的概念，其发挥了宏函数的优势，同时避免了宏函数错误。  

内联函数（inline function）是一种提示编译器将函数调用替换为函数体代码的优化技术。通过将函数调用替换为函数代码，内联函数可以减少函数调用的开销，尤其是在频繁调用的小函数中。这种优化可以提高程序的运行效率。

```cpp
#include <iostream>

inline int multiply(int a, int b) {
    return a * b;
}

int main() {
    int x = 5, y = 10;
    std::cout << "Product: " << multiply(x, y) << std::endl;
    return 0;
}
```

### 3.1 内联函数和宏定义的区别

宏定义仅仅是字符串替换，而内联函数是一个函数，具有函数的性质，可以向函数一样调试，而宏定义不能。

### 3.2 宏展开错误

宏展开错误通常是指在使用宏定义时，由于文本替换规则而导致的意想不到的结果。这些错误可能会引起程序的行为不如预期，甚至引发难以调试的问题。常见的宏展开错误包括**运算符优先级问题、多次计算副作用和缺少括号等**。e.g.

```cpp
#define SQUARE(x) x * x

int result = SQUARE(1 + 2); // 期望结果是 9，但实际结果是 1 + 2 * 1 + 2 = 5
```

### 3.3 内联函数的常识性问题

- 内联函数可以被重载。
- 构造函数可以被定义成内联函数（不建议，可能会代码量过大）。
- 必须在函数定义时使用inline关键字，在声明时不能使用。

## 4. 内存分配

- C语言中，通过malloc函数动态申请空间，通过free函数将空间释放。  
- 通过malloc函数申请空间的时候，首先会扫描可用空间链表，直到发现第一个大于申请空间的可用空间，将这段可用空间的首地址返回，并利用剩余空间的首地址和大小更新链表。  
- **动态分配的空间来自堆空间**，指针指向堆空间的地址，而指针本身存放在栈空间中。  
- 可用空间不够时，malloc会分配一个空指针。
- malloc和free必须成对出现，不存在一个malloc多个free。
- 不及时释放空间容易造成内存泄露。
- free掉空间以后，最好立刻将指针置空，因为释放空间以后指针指向地址的内容没有变，无法通过指针本身判断空间是否已经释放。

### 4.1 malloc/free和new/delete的区别

- malloc/free是C语言提供的内存管理函数，C++中也可以使用，而new/delete是C++提供的运算符。
- malloc/free只可以用于基本类型，而new/delete不仅可以用于基本类型，而且可以用于面向对象的自定义类型。
- **malloc返回的是void *，需要程序显示的转换指针类型**，new后面直接指明了类型。
- malloc只负责申请空间，返回首地址，而new还会调用构造函数初始化指针指向的内容；free只负责释放空间，delete还会调用析构函数。

### 4.2 delete和delete[]的区别

- 用途不同：
  - delete用于单个对象。
  - delete[]用于数组。

- 析构函数的调用：
  - delete调用单个对象的析构函数。
  - delete[]调用数组中每个元素的析构函数。

- 内存释放的机制：
  - delete只释放单个对象的内存。
  - delete[]释放整个数组的内存，包括数组中每个元素的内存。

```cpp
int* arr = new int[10]; // 动态分配一个int数组
delete arr; // 未定义行为，应该使用delete[]
delete[] arr; // 释放数组的内存并调用每个元素的析构函数（如果有）
```

## 5. main函数

main函数有两种形式：

```cpp
int main()
int main(int argc, char* argv[])
```

带参数的main函数参数是固定的，argc是argument count的缩写，表示命令行输入参数的个数。argv是argument value的缩写，字符串指针数组类型，首元素argv[0]是程序的名字，其余是命令行输入的参数。

