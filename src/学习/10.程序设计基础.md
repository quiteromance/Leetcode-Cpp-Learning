# 程序设计基础

## 目录

- [程序设计基础](#程序设计基础)
  - [目录](#目录)
  - [1. 程序的编译和执行](#1-程序的编译和执行)
    - [1.1 #include\<\>和#include ""的区别](#11-include和include-的区别)
    - [1.2 简述#和##在define中的作用](#12-简述和在define中的作用)
  - [2. 变量](#2-变量)
    - [2.1 C++的类型转换操作符](#21-c的类型转换操作符)
    - [2.2 静态全局变量](#22-静态全局变量)


## 1. 程序的编译和执行

### 1.1 #include<>和#include ""的区别

- #include<>直接从编译器指定的路径处搜索
- #include ""优先在当前目录下搜索，再从编译器指定的目录下搜索。

### 1.2 简述#和##在define中的作用

- #将后面的参数转换成字符串。e.g.

```cpp
#define PRINTCUBE(x) cout << "cube("<< #x <<") = " << (x) * (x) * (x) << endl;

int y = 5;
PRINTCUBE(5);
PRINTCUBE(y);

// 输出结果为：cube(5) = 125;cube(y) = 125;
```

- ##将前后参数进行字符串连接。e.g.

```cpp
#define LINK(x, y, z) x##y##z
LINK(3,5,0);

// 结果为350
```

## 2. 变量

### 2.1 C++的类型转换操作符

- C++提供了四种类型转换操作符：#static_cast#；#dynamic_cast#；#const_cast#和#reinterpret_cast#。
- static_cast可以代替C风格类型转化实现基本类型转换，可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针（如果两个类是不相关的，则不可以相互转换）。
  - 需要注意的是，如果父类指针本就指向一个父类对象，此时将父类指针转换成子类指针虽然可以用static_cast实现，但是是不安全的；如果父类指针指向子类对象，则转换不存在安全性问题。

```cpp
class Base {};
class Derived : public Base {};

Base *b1 = new Base;
Base *b2 = new Derived;

Derived *b2d1 = static_cast<Derived*> (b1); //（不安全的转换）
Derived *b2d2 = static_cast<Derived*> (b2); // （安全的转换）
```

- dynamic_cast可以将父类指针转换成子类指针，也可以将子类指针转换成父类指针。其在将父类指针转换成子类指针的过程中，需要对其背后的对象进行检查以确保类型完全批配（static_cast不会这样做）。当一个父类指针指向一个子类对象，且父类包含虚函数的时候，使用dynamic_cast转换子类指针才会成功，否则返回nullptr或抛出 std::bad_cast 异常（对于引用类型）。
  
```cpp
class Base {
public:
    virtual ~Base() {} // 必须有虚函数以使dynamic_cast起作用
};

class Derived1 : public Base {};

class Derived2 : public Base {};

Base *b1 = new Base;
Base *b2 = new Derived;

Derived *b2d1 = dynamic_cast<Derived*> (b1); //转换失败，返回nullptr
Derived *b2d2 = dynamic_cast<Derived*> (b2); //转换成功

Derived &b2d3 = dynamic_cast<Derived*> (b1); //转换失败，抛出 std::bad_cast 异常
Derived &b2d4 = dynamic_cast<Derived*> (b2); //转换成功

```

- const_cast可以在转换过程中增加或删除const属性。
- reinterpret_cast可以将一种类型的指针直接转换成另一种类型的指针（不论是否有继承关系），或者将指针类型转换为整数类型（反之亦然）。但需要开发者非常小心，因为这种转换可能会导致未定义行为（reinterpret_cast 不会进行任何运行时检查，因此转换的结果可能会导致未定义行为。必须确保转换是合理的）。

### 2.2 静态全局变量

静态全局变量的声明和定义放在源文件中，并且不能使用extern关键字将静态全局变量导出，因此静态全局变量的作用域仅限于定义静态全局变量的文件内部。