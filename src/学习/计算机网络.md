# 计算机网络

## 目录

- [计算机网络](#计算机网络)
  - [目录](#目录)
  - [运输层](#运输层)
    - [运输层的端口](#运输层的端口)
    - [UDP协议特点](#udp协议特点)
    - [TCP协议特点](#tcp协议特点)
    - [TCP可靠传输的实现](#tcp可靠传输的实现)
      - [以字节为单位的滑动窗口](#以字节为单位的滑动窗口)
      - [TCP的流量控制](#tcp的流量控制)
      - [TCP的拥塞控制](#tcp的拥塞控制)
      - [TCP的运输连接管理](#tcp的运输连接管理)
        - [TCP连接建立](#tcp连接建立)
        - [TCP的连接释放](#tcp的连接释放)

## 运输层

- **运输层向其最上面的应用层提供服务**，他是面向通信的最高层，也是用户功能的最低层。
- 进行通信的实体是主机间的**进程**，是一台主机中的进程和另一台主机中的进程交换数据。所以两台主机间的通信就是应用进程的相互通信。IP协议能把分组送到目的主机，但是还停留在主机的网络层。而从运输层的角度来看，通信的端点**不是主机而是主机中的进程**。
- 运输层功能：复用`multiplexing`和分用`demultiplexing`。复用是指发送方不同的进程都可以使用同一个运输层协议传输数据，分用指接收方运输层在剥去保温首部以后能够把数据正确的交付目的应用进程。
- 逻辑通信：从应用层看，只要把应用层的报文交给运输层，运输层就能把这条报文交给对方的运输层。故**网络层为主机之间提供逻辑通信，而运输层为应用进程提供端到端的逻辑通信**。
- 运输层屏蔽下面网络的核心细节，使应用进程看见的好像是在两个运输层实体之间有一条端到端的逻辑通信信道。
- 运输层两个主要协议：***UDP（User Datagram Protocol）***用户数据报协议和***TCP（Transmission Control Protocol）***传输控制协议。

### 运输层的端口

- 由于进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程。我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个。为了解决这个问题，运输层使用协议端口号，或者**端口**。
- 端口是应用层各种协议进程与运输实体进行层间交互的一种地址。TCP/UDP报文中都有源端口和目的端口，当运输层接收到IP层上交的运输层报文的时候，就能通过首部的目的端口号把数据交付到目的应用进程。
  
  - 系统端口号（0-1023）：TCP/IP最重要的应用程序，如http，https等。
  - 用户端口号（1024-49151）：，这些端口是为特定应用或服务所保留的，通常由用户或开发者自行选择使用。必须登记使用，防止重复。
  - 客户端使用端口号（49152-65535）：又称动态/临时端口，留给客户进程短暂使用。比如当客户端（如浏览器、FTP 客户端等）发起与服务器的连接时，操作系统会自动从这个范围内选择一个端口号用于临时会话。

### UDP协议特点

- UDP是无连接的。发送数据之前不需要建立连接，减少了开销和发送数据的时延。
- UDP使用尽最大努力交付，不保证可靠数据。
- UDP是**面向报文**传输。即发送方UDP对应用程序交下来的报文，在添加首部后就交付IP层。UDP对应用层发下来的报文，既不合并，也不拆分。
- UDP没有拥塞控制，网络出现拥塞不会使源主机发送速率降低。比如视频会议，实时通话等。
- UDP支持一对一、一对多、多对一、多对多的交互通信。
- UDP首部开销小。

### TCP协议特点

- TCP是**面向连接的传输协议**。应用程序在使用TCP协议前，必须建立TCP连接。在传输数据完毕以后，必须释放TCP连接。
- 每一条TCP连接只能有两个端点，每一条TCP连接只能是**一对一**的。
- TCP连接提供**可靠**交付的服务。通过TCP连接传送数据，无差错，不丢失，不重复，按序到达。
- TCP提供**全双工通信**。TCP允许通信双方应用在任何时间都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
- 面向**字节流**。字节流含义：虽然应用程序和TCP的交互是一次一个数据块，但是TCP把应用程序交下来的数据看成一连串的**无结构字节流**。TCP不保证接收方收到的数据块和应用方发送的数据块的对应关系，但接收方应用程序接受到的字节流应该和应用方发出的字节流完全一样。

### TCP可靠传输的实现

#### 以字节为单位的滑动窗口

1. 情景设定：假设A收到了B发来的确认报文。A的窗口是20个字节，确认号是31（表明B期望收到的下一个序号是31，而30为止的数据都已经收到了）。
2. 发送窗口会在没有收到B确认报文的情况下，将A中滑动窗口中的数据全部发送出去。凡是已经发送过的数据，未收到确认之前都需要保留，以便超市重传使用。
3. 描述发送窗口的状态需要有3个指针P1，P2，P3.小于P1是已经发送并收到确认的部分，大于P3是不允许发送的部分。P2-P1是已经发送但是还没有确认的字节数，P3-P2是允许发送但是还没有发送的字节数。
4. 如果B接收到了序号为31-33的数据，B将这些数据包交给主机，然后将接收窗口后移3个单位，并且发送一个序号为34的确认报文给A。A收到确认，就将窗口后移三个单位，P1和P3变了，P2不变。如果A没有收到确认，一段时间后会触发超时重传机制。
5. 对于不按序到达大的数据如何处理，TCP报文并没有明确的规定。TCP通常对不按序到达的数据先临时存放在窗口中，等待数据补全后再发送确认报文。

#### TCP的流量控制

流量控制（flow control）就是让发送方发送速率不要太快。利用滑动窗口机制可以实现。

- 建立连接时，B告诉A“我的接收窗口rwnd = 400”。发送方的发送窗口不能超过接收方的接收窗口。
- B可以通过接收窗口的大小来进行流量控制，当rwnd = 0时，A停止发送报文直到B发送一个新的窗口值。
- 如果B发送的rwnd报文丢失了，A会一直处于等待状态，B也会处于等待A发送报文的状态，这个时候就会发生死锁。此时TCP会启动计时器，当连接的一方接收到零窗口通知就会启动，每隔一段时间会发送一个探测报文，对方接受到以后就会给出现在的窗口值，接收到以后就重制计时器。

#### TCP的拥塞控制

当网络中对资源的需求大于可用资源时，就会发生拥塞。
  
其中TCP的拥塞控制算法有四种：

- 慢开始（slow-start）
- 拥塞避免（congestion avoidance）
- 快重传（fast retransmit）
- 快恢复（fast recovery）

---
慢开始

- 发送方位置一个拥塞窗口cwnd的状态变量，大小取决于网络的拥塞程度，并且动态的变化。发送方让自己的发送窗口等于拥塞窗口。
- 只要网络没有出现拥塞，拥塞窗口就可以再增大一点，以便将更多的分组发送出去，这样可以提高网络的利用率。但只要网络出现拥塞或可能出现拥塞，就会减小拥塞窗口。
- 只要发生了超时，可以猜想网络发生了拥塞。
- 慢开始的思路：

  - 主机发送数据的时候，由小到大逐渐增大发送窗口（拥塞窗口）的值。先设定cwnd为1至2个发送方最大报文段。
  - 每次收到确认报文的时候，cwnd翻倍。
  - 当cwnd大于慢开始门限（ssthresh），执行拥塞避免算法。

---
拥塞避免

- 拥塞避免算法思路是让拥塞窗口cwnd缓慢的增大，即每次经过一个往返时间RTT就把发送方的拥塞窗口cwnd+1。
- 当拥塞窗口达到一定的时候的时候发生超时，此时调整门限为原来的1/2，同时设置cwnd=1，重新开始慢开始算法。

---
快重传

- 快重传可以让发送方尽快直到个别报文段的丢失。
- 快重传算法要求接收方立刻发送确认报文，即使是自己收到了失序的报文。比如M3报文没有接受，发送方发送M4，M5，M6报文并被接受接收方以后也会重复发送M2的确认报文。
- 快重传算法规定，发送方只要连续接收到了三个重复确认，截止到没有接收到M3，需要立刻重新发送M3.

---
快恢复

- 快充穿以后直接将门限调整为原来的1/2，并且执行拥塞避免算法。

#### TCP的运输连接管理

TCP运输连接有三个阶段：

- 连接建立
- 数据传输
- 连接释放

TCP连接建立有三个问题：

- 每一方都要确认对方的存在
- 允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项等等）
- 能对运输实体资源（如缓存大小、连接表中的项目）进行分配

##### TCP连接建立

假定A运行TCP客户程序，运行TCP服务器程序。一开始两个程序都处于CLOSED状态。现在A主动打开连接，B被动打开链接。

- B的TCP服务器进程先创建传输控制块TCB。服务器处于LISTEN状态，等待客户的连接请求，如果有的话就立刻做出响应。
- A的TCP客户进程也是首先创建传输控制模块。然后在打算建立TCP连接时，**向B发出连接请求报文段（SYN报文段），这时首部的同步位SYN=1，同时选择一个初始序号seq = x。**TCP规定SYN报文段不能携带数据，但是消耗掉一个序号。**此时TCP客户进程进入SYN-SENT状态（同步以发送）**。
- B收到连接请求报文后，如果同意建立连接，则向A发送确认报文。在确认报文中将SYN位和ACK位都置1，确认号ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但也消耗掉一个序号。**这时TCP的客户端进程进入SYN-RCVD**（同步收到状态）。
- TCP客户进程收到B确认以后，还要给B给出确认。确认报文端的ACK置1，确认号ack=y+1，自己的序号seq=x+1。TCP规定，ACK的报文段可以携带数据，但如果不携带数据就不消耗序号，这样下一个报文的序号还是x+1。
- TCP连接建立，A进入ESTABLISHED状态。
- B接收到确认报文，B进入ESTABLISHED状态。

**为什么A最后还要发送一次确认？**  
为了防止已经失效的连接请求报文段突然又传送到了B，因此产生错误。

##### TCP的连接释放

数据传输结束后，通信的**双方**都可以释放连接。现在A和B都处于ESTABLISHED状态。

- A应用先向TCP发出连接释放报文，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段的首部终止控制位FIN置1，其序号seq=u，等于前面传送数据最后一个字节的序号+1.这时**A进入FIN-WAIT-1（停止等待1）状态**，等待B的确认。FIN报文不携带数据也会消耗一个序号。
- B收到连接释放报文段后发出确认。确认号ack=u+1，这个报文自己的seq=v。然后**B进入CLOSE-WAIT（关闭等待）的状态**。TCP服务器通知高层应用，从A到B这个方向的连接就释放了。这时TCP连接处于**半关闭**状态。因为A没有数据要发送了，但是如果B发送数据，A仍要接收。
- A收到B的确认报文后，会进入FIN-WAIT-2（停止等待2）状态，等待B释放报文段。
- 如果B没有要向A发送的报文，B发出的连接释放报文使FIN=1，假定B的序号是w。B要重复上一个发送过的ack=u+1。这时**B进入LAST-ACK（最后确认）**状态。
- A收到B的连接释放报文后，必须发出确认，确认报文ACK置1，确认号ack=w+1，自己的序号是seq=u+1.随后**进入到TIME-WAIT状态**。纪念馆过时间等待计时器设置时间后，A进入CLOSE状态。
- B收到A的确认报文，B进入CLOSE状态。

**为什么需要TIME-WAIT状态？**

- 第一：为了保证A发送的最后一个ACK报文段能到达B。
- 第二：防止已经失效的连接请求报文出现在本次连接中。
